using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AotAssemblyScan;

[Generator]
public sealed class AssemblyScanGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var partialAssemblyScanMethodsProvider = context
           .SyntaxProvider
           .ForAttributeWithMetadataName(
                WellKnownNamings.AssemblyScanAttribute,
                predicate: (node, _) => node is MethodDeclarationSyntax,
                transform: (ctx, _) => (MethodDeclarationSyntax) ctx.TargetNode)
           .Where(syntax => syntax.AttributeLists.Count > 0)
           .Where(syntax => syntax.Modifiers.Any(SyntaxKind.PartialKeyword));

        var compilationWithMethods = context
           .CompilationProvider
           .Combine(partialAssemblyScanMethodsProvider.Collect());

        context.RegisterSourceOutput(
            compilationWithMethods,
            GenerateCode);
    }

    private void GenerateCode(
        SourceProductionContext context,
        (Compilation Left, ImmutableArray<MethodDeclarationSyntax> Right) source)
    {
        var (compilation, methods) = source;

        foreach (var method in methods.Distinct())
        {
            var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
            var methodSymbol = ModelExtensions.GetDeclaredSymbol(semanticModel, method)!;

            var attributes = ExtractGenericTypeAttributes(methodSymbol);
            var matchingTypes = ScanAssemblyForMatchingTypes(compilation, attributes);
            var sourceText = GenerateMethodImplementation(methodSymbol, matchingTypes);

            var @namespace = methodSymbol.ContainingNamespace.ToDisplayString();
            var @class = methodSymbol.ContainingType.Name;
            var methodName = methodSymbol.Name;

            context.AddSource(
                $"{@namespace}_{@class}_{methodName}_Generated.cs",
                SourceText.From(sourceText, Encoding.UTF8));
        }
    }

    private static List<(string AttributeKind, INamedTypeSymbol TypeSymbol)> ExtractGenericTypeAttributes(
        ISymbol methodSymbol)
    {
        return methodSymbol
           .GetAttributes()
           .Where(a =>
                a.AttributeClass is not null &&
                (a.AttributeClass.Name.StartsWith("HasAttributeAttribute") ||
                 a.AttributeClass.Name.StartsWith("ImplementsAttribute")) &&
                a.AttributeClass.IsGenericType)
           .Select(attr => (attr.AttributeClass!.Name, attr.AttributeClass.TypeArguments[0] as INamedTypeSymbol))
           .Where(pair => pair.Item2 is not null)
           .ToList()!;
    }

    private static List<INamedTypeSymbol> ScanAssemblyForMatchingTypes(
        Compilation compilation,
        List<(string AttributeKind, INamedTypeSymbol TypeSymbol)> filters)
    {
        var result = new List<INamedTypeSymbol>();

        foreach (var tree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(tree);
            var root = tree.GetRoot();

            var typeDeclarations = root
               .DescendantNodes()
               .OfType<TypeDeclarationSyntax>();

            foreach (var typeDeclaration in typeDeclarations)
            {
                if (ModelExtensions.GetDeclaredSymbol(semanticModel, typeDeclaration) is not INamedTypeSymbol typeSymbol)
                    continue;

                bool matchesAttributes = filters
                   .Where(f => f.AttributeKind.StartsWith("HasAttribute"))
                   .All(f => typeSymbol.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, f.TypeSymbol)));

                bool matchesInterfaces = filters
                   .Where(f => f.AttributeKind.StartsWith("Implements"))
                   .All(f => typeSymbol.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, f.TypeSymbol)));

                if (matchesAttributes && matchesInterfaces)
                {
                    result.Add(typeSymbol);
                }
            }
        }

        return result;
    }

    private static string GenerateMethodImplementation(ISymbol methodSymbol, List<INamedTypeSymbol> types)
    {
        var methodNamespace = methodSymbol.ContainingNamespace.ToDisplayString();
        var typeList = string.Join(", ", types.Select(t => $"typeof({t.ToDisplayString()})"));

        return $$"""
                 // <auto-generated />

                 using System;
                 using System.Collections.Generic;

                 namespace {{methodNamespace}}
                 {
                     public static partial class {{methodSymbol.ContainingType.Name}}
                     {
                         public static partial IReadOnlyList<Type> {{methodSymbol.Name}}()
                         {
                             return new Type[] { {{typeList}} };
                         }
                     }
                 }

                 """;
    }
}
